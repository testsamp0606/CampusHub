
/**
 * Core Philosophy: This ruleset enforces a strict multi-tenant security model where all data is partitioned by a school.
 * A user's access to any resource is contingent on their verified membership within a specific school, which is
 * determined by their user profile located at /schools/{schoolId}/users/{userId}.
 *
 * Data Structure: All application data is nested under the top-level `schools` collection. Each school document,
 * identified by a unique `schoolId`, serves as the root for all related data, including users, students, classes,
 * and financial records. This hierarchical structure ensures strong data isolation between different schools.
 *
 * Key Security Decisions:
 * - SuperAdmin Override: A 'SuperAdmin' role, set via custom claims, has unrestricted access to all data across all schools.
 * - School Segregation: The primary security boundary is the school. A user authenticated for one school cannot read,
 *   write, or even see data belonging to another, unless they are a SuperAdmin. This is enforced by the `isSchoolMember(schoolId)` function.
 * - Role-Based Writes: While any member of a school has broad read access within their school's data, write permissions
 *   (create, update, delete) for most collections are restricted to users with an 'admin' role. This provides a secure
 *   default for managing school-wide data.
 * - User Profile Management: Users are empowered to create and manage their own profiles within a school, allowing for a
 *   self-service "join" or "onboarding" flow. However, only school admins can remove users or modify other users' profiles.
 *
 * Denormalization for Authorization: To ensure fast and secure authorization checks, all documents within a school's
 * subcollections (e.g., students, classes, expenses) must contain a denormalized `schoolId` field. Security rules
 * validate this field on all write operations to maintain relational integrity and prevent data from being associated
 * with the wrong school. This avoids slow and costly cross-document `get()` calls in most rules.
 *
 * Structural Segregation: Each data type (students, teachers, assets, etc.) is stored in its own dedicated collection.
 * This ensures that security rules are simple and specific to the data they protect, and allows for secure and
 * performant list operations for clients.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * =====================================================================
     *    HELPER FUNCTIONS
     * =====================================================================
     */

    // Checks if the user is authenticated via Firebase Auth.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user's UID matches the given userId wildcard from the path.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Checks if the user is a SuperAdmin via custom claims. SuperAdmins have universal access.
    function isSuperAdmin() {
      return isSignedIn() && request.auth.token.isSuperAdmin == true;
    }
    
    // Retrieves the user's role data from their profile document.
    function getUserRole(schoolId) {
      return get(/databases/$(database)/documents/schools/$(schoolId)/users/$(request.auth.uid)).data.role;
    }
    
    // Constructs the path to a user's profile document for a given school and user ID.
    function getUserDataPath(schoolId, userId) {
      return /databases/$(database)/documents/schools/$(schoolId)/users/$(userId);
    }

    // Checks if the requesting user is a registered member of the specified school.
    // This is the foundational check for almost all data access. It performs a single document read.
    function isSchoolMember(schoolId) {
      return isSuperAdmin() || (isSignedIn() && exists(getUserDataPath(schoolId, request.auth.uid)));
    }

    // Checks if the requesting user has the 'admin' role within the specified school.
    function isSchoolAdmin(schoolId) {
      return isSuperAdmin() || (isSchoolMember(schoolId) && getUserRole(schoolId) == 'admin');
    }

    /**
     * Common validation functions for write operations within any school subcollection.
     * These functions ensure that data is correctly linked to its parent school.
     */
    // On create, ensures the new document's schoolId field matches the path.
    function schoolIdMatchesPath(schoolId) {
      return request.resource.data.schoolId == schoolId;
    }

    // On update, ensures the schoolId field is immutable, preventing re-association.
    function schoolIdIsImmutable() {
      return request.resource.data.schoolId == resource.data.schoolId;
    }

    /**
     * Common access control rule sets for most school subcollections.
     * These bundle common logic for readability.
     */
    // Grants read access to any verified member of the school or a SuperAdmin.
    function canReadSchoolData(schoolId) {
      return isSchoolMember(schoolId);
    }

    // Grants create access to school admins and validates data integrity.
    function canCreateSchoolData(schoolId) {
      return isSchoolAdmin(schoolId) && schoolIdMatchesPath(schoolId);
    }

    // Grants update/delete access to school admins and ensures document existence.
    function canModifySchoolData(schoolId) {
      return resource != null && isSchoolAdmin(schoolId) && schoolIdIsImmutable();
    }


    /**
     * @description Controls access to the main school documents.
     * @path /schools/{schoolId}
     */
    match /schools/{schoolId} {
      allow get, list: if isSchoolMember(schoolId);
      allow create: if false; // School creation should be an admin/backend process
      allow update: if isSchoolAdmin(schoolId);
      allow delete: if false; // School deletion should be an admin/backend process
      
      /**
       * @description Controls access to user profiles within a school.
       * @path /schools/{schoolId}/users/{userId}
       */
      match /users/{userId} {
        allow read: if isSchoolMember(schoolId);
        allow create: if isOwner(userId) && schoolIdMatchesPath(schoolId);
        allow update: if (isOwner(userId) || isSchoolAdmin(schoolId)) && schoolIdIsImmutable();
        allow delete: if isSchoolAdmin(schoolId);
      }

      /**
       * @description Generic rules for most school data subcollections.
       * @principle Grants read access to any school member, but restricts writes to admins.
       */
      match /students/{studentId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /teachers/{teacherId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /classes/{classId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
      
      match /subjects/{subjectId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /attendances/{attendanceId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /expenses/{expenseId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /accounts/{accountId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /assets/{assetId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /events/{eventId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
      
      /**
       * @description Controls access to conversation threads.
       * @path /schools/{schoolId}/conversations/{conversationId}
       */
      match /conversations/{conversationId} {
        allow get: if isSchoolMember(schoolId) && (isSuperAdmin() || request.auth.uid in resource.data.participantIds);
        allow list: if isSchoolMember(schoolId) && (isSuperAdmin() || request.query.where.participantIds_array_contains == request.auth.uid);
        allow create: if isSchoolMember(schoolId) && request.auth.uid in request.resource.data.participantIds && schoolIdMatchesPath(schoolId);
        allow update: if isSchoolMember(schoolId) && request.auth.uid in resource.data.participantIds && schoolIdIsImmutable();
        allow delete: if false;

        /**
         * @description Controls access to messages within a conversation.
         * @path /schools/{schoolId}/conversations/{conversationId}/messages/{messageId}
         */
        match /messages/{messageId} {
          allow read: if isSchoolMember(schoolId) && (isSuperAdmin() || request.auth.uid in get(parent).data.participantIds);
          allow create: if isSchoolMember(schoolId) && request.resource.data.senderId == request.auth.uid && (isSuperAdmin() || request.auth.uid in get(parent).data.participantIds);
          allow update, delete: if false;
        }
      }
      
      match /books/{bookId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
      
      match /bookIssues/{issueId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /vehicles/{vehicleId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /routes/{routeId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
      
      match /studentTransports/{allocationId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /fees/{feeId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /timetables/{timetableId} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }

      match /permissions/{roleName} {
        allow read: if canReadSchoolData(schoolId);
        allow write: if isSchoolAdmin(schoolId);
      }
    }
  }
}
